!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Bicyclist	UNet/data.py	/^Bicyclist = [0,128,192]$/;"	v
Building	UNet/data.py	/^Building = [128,0,0]$/;"	v
COLOR_DICT	UNet/data.py	/^COLOR_DICT = np.array([Sky, Building, Pole, Road, Pavement,$/;"	v
CONCAT	Layer.py	/^    CONCAT = 4$/;"	v	class:LayerType
CONV	Layer.py	/^    CONV = 1$/;"	v	class:LayerType
Car	UNet/data.py	/^Car = [64,0,128]$/;"	v
ComputationUnit	Components/ComputationUnit.py	/^class ComputationUnit():$/;"	c
ComputationUnit	Components/InputBuffer.py	/^from . import ComputationUnit as ComputationUnit$/;"	i
ComputationUnit	Components/OutputBuffer.py	/^from . import ComputationUnit as ComputationUnit$/;"	i
ComputationUnit	uArch.py	/^from Components.ComputationUnit import ComputationUnit$/;"	i
DOWN_SAMPLE	Layer.py	/^    DOWN_SAMPLE = 2$/;"	v	class:LayerType
DROP_OUT	Layer.py	/^    DROP_OUT = 6$/;"	v	class:LayerType
Fence	UNet/data.py	/^Fence = [64,64,128]$/;"	v
INPUT	Layer.py	/^    INPUT = 5$/;"	v	class:LayerType
ImageDataGenerator	UNet/data.py	/^from tensorflow.keras.preprocessing.image import ImageDataGenerator$/;"	i
InputBuffer	Components/ComputationUnit.py	/^from . import InputBuffer as InputBuffer$/;"	i
InputBuffer	Components/InputBuffer.py	/^class InputBuffer():$/;"	c
InputBuffer	Components/VMem.py	/^from . import InputBuffer as InputBuffer$/;"	i
InputBuffer	uArch.py	/^from Components.InputBuffer import InputBuffer$/;"	i
KernelPostion	Components/InputBuffer.py	/^class KernelPostion():$/;"	c
Layer	Components/VMem.py	/^from Layer import Layer, LayerType, PadType$/;"	i
Layer	Layer.py	/^class Layer():$/;"	c
LayerType	Components/VMem.py	/^from Layer import Layer, LayerType, PadType$/;"	i
LayerType	Layer.py	/^class LayerType(enum.Enum):$/;"	c
LearningRateScheduler	UNet/model.py	/^from tensorflow.keras.callbacks import ModelCheckpoint, LearningRateScheduler$/;"	i
ModelCheckpoint	UNet/model.py	/^from tensorflow.keras.callbacks import ModelCheckpoint, LearningRateScheduler$/;"	i
NONE	Layer.py	/^    NONE = 3  # for non-convolutional layers$/;"	v	class:PadType
OutputBuffer	Components/ComputationUnit.py	/^from . import OutputBuffer as OutputBuffer$/;"	i
OutputBuffer	Components/OutputBuffer.py	/^class OutputBuffer():$/;"	c
OutputBuffer	Components/VMem.py	/^from . import OutputBuffer as OutputBuffer$/;"	i
OutputBuffer	uArch.py	/^from Components.OutputBuffer import OutputBuffer$/;"	i
PE	Components/ComputationUnit.py	/^class PE():$/;"	c
PadType	Components/VMem.py	/^from Layer import Layer, LayerType, PadType$/;"	i
PadType	Layer.py	/^class PadType(enum.Enum):$/;"	c
Pavement	UNet/data.py	/^Pavement = [60,40,222]$/;"	v
Pedestrian	UNet/data.py	/^Pedestrian = [64,64,0]$/;"	v
Pole	UNet/data.py	/^Pole = [192,192,128]$/;"	v
Road	UNet/data.py	/^Road = [128,64,128]$/;"	v
SAME	Layer.py	/^    SAME = 1$/;"	v	class:PadType
SignSymbol	UNet/data.py	/^SignSymbol = [192,128,128]$/;"	v
Sky	UNet/data.py	/^Sky = [128,128,128]$/;"	v
Tree	UNet/data.py	/^Tree = [128,128,0]$/;"	v
UP_SAMPLE	Layer.py	/^    UP_SAMPLE = 3$/;"	v	class:LayerType
Union	Components/VMem.py	/^from typing import Union$/;"	i
Unlabelled	UNet/data.py	/^Unlabelled = [0,0,0]$/;"	v
VALID	Layer.py	/^    VALID = 2$/;"	v	class:PadType
VMem	Components/InputBuffer.py	/^from . import VMem as VMem$/;"	i
VMem	Components/OutputBuffer.py	/^from . import VMem as VMem$/;"	i
VMem	Components/VMem.py	/^class VMem():$/;"	c
VMem	uArch.py	/^from Components.VMem import VMem$/;"	i
__init__	Components/ComputationUnit.py	/^    def __init__(self):$/;"	m	class:PE
__init__	Components/ComputationUnit.py	/^    def __init__(self, pe_array_size: int) -> None:$/;"	m	class:ComputationUnit
__init__	Components/InputBuffer.py	/^    def __init__(self):$/;"	m	class:InputBuffer
__init__	Components/InputBuffer.py	/^    def __init__(self, strides: int, kernel_num: int):$/;"	m	class:KernelPostion
__init__	Components/OutputBuffer.py	/^    def __init__(self) -> None:$/;"	m	class:OutputBuffer
__init__	Components/VMem.py	/^    def __init__(self) -> None:$/;"	m	class:VMem
__init__	Layer.py	/^    def __init__(self, layer_type: LayerType, name: str) -> None:$/;"	m	class:Layer
__init__	uArch.py	/^    def __init__(self, pe_array_size: int = 32) -> None:$/;"	m	class:uArch
__str__	Layer.py	/^    def __str__(self) -> str:$/;"	m	class:Layer	file:
_check	Components/InputBuffer.py	/^    def _check(self) -> None:$/;"	m	class:InputBuffer
_computeConcatShape	Layer.py	/^    def _computeConcatShape(self, layer_map: dict) -> tuple:$/;"	m	class:Layer
_computeConvShape	Layer.py	/^    def _computeConvShape(self, input_shape: tuple) -> tuple:$/;"	m	class:Layer
_computeDownSampleShape	Layer.py	/^    def _computeDownSampleShape(self, input_shape: tuple) -> tuple:$/;"	m	class:Layer
_computeShape	uArch.py	/^    def _computeShape(self) -> None:$/;"	m	class:uArch
_computeUpSampleShape	Layer.py	/^    def _computeUpSampleShape(self, input_shape: tuple) -> tuple:$/;"	m	class:Layer
_loadVMem	uArch.py	/^    def _loadVMem(self) -> None:$/;"	m	class:uArch
_nextRound	Components/InputBuffer.py	/^    def _nextRound(self) -> tuple:$/;"	m	class:InputBuffer
_paramTypeTransfrom	Components/VMem.py	/^    def _paramTypeTransfrom(self, kernel_size: Union[int,tuple], strides: Union[int,tuple], pad: Union[str,PadType]) -> tuple:$/;"	m	class:VMem
_read	Components/InputBuffer.py	/^    def _read(self) -> None:$/;"	m	class:InputBuffer
_readInput	uArch.py	/^    def _readInput(self, input_path: str) -> np.array:$/;"	m	class:uArch
addConcatLayer	Components/VMem.py	/^    def addConcatLayer(self, name: str, src: str, dst: str) -> None:$/;"	m	class:VMem
addConvLayer	Components/VMem.py	/^    def addConvLayer(self, name: str, filters: int, kernel_size: Union[int,tuple], strides: Union[int,tuple], pad: Union[str,PadType]) -> None:$/;"	m	class:VMem
addDropoutLayer	Components/VMem.py	/^    def addDropoutLayer(self, name: str, rate: float) -> None:$/;"	m	class:VMem
addInputLayer	Components/VMem.py	/^    def addInputLayer(self, name: str, input_shape: tuple) -> None:$/;"	m	class:VMem
addMaxPoolingLayer	Components/VMem.py	/^    def addMaxPoolingLayer(self, name: str, kernel_size: Union[int,tuple], strides: Union[int,tuple], pad: Union[str,PadType]) -> None:$/;"	m	class:VMem
addUpSamplingLayer	Components/VMem.py	/^    def addUpSamplingLayer(self, name: str, kernel_size: Union[int,tuple]) -> None:$/;"	m	class:VMem
adjustData	UNet/data.py	/^def adjustData(img,mask,flag_multi_class,num_class):$/;"	f
argparse	Sim.py	/^import argparse$/;"	i
checkData	Components/OutputBuffer.py	/^    def checkData(self) -> None:$/;"	m	class:OutputBuffer
computeNextRound	Components/ComputationUnit.py	/^    def computeNextRound(self) -> None:$/;"	m	class:ComputationUnit
computeShape	Layer.py	/^    def computeShape(self, layer_map: dict, input_shape: tuple) -> tuple:$/;"	m	class:Layer
dataFetch	Components/ComputationUnit.py	/^    def dataFetch(self) -> tuple:$/;"	m	class:ComputationUnit
dataWrite	Components/ComputationUnit.py	/^    def dataWrite(self, output_buffer: OutputBuffer) -> tuple:$/;"	m	class:ComputationUnit
enum	Layer.py	/^import enum$/;"	i
geneTrainNpy	UNet/data.py	/^def geneTrainNpy(image_path,mask_path,flag_multi_class = False,num_class = 2,image_prefix = "image",mask_prefix = "mask",image_as_gray = True,mask_as_gray = True):$/;"	f
getInputShape	Layer.py	/^    def getInputShape(self) -> tuple:$/;"	m	class:Layer
getModelInputShape	Components/VMem.py	/^    def getModelInputShape(self) -> tuple:$/;"	m	class:VMem
glob	UNet/data.py	/^import glob$/;"	i
io	UNet/data.py	/^import skimage.io as io$/;"	i
io	Utility.py	/^        import skimage.io as io$/;"	i
io	uArch.py	/^import skimage.io as io$/;"	i
labelVisualize	UNet/data.py	/^def labelVisualize(num_class,color_dict,img):$/;"	f
layerStat	Components/VMem.py	/^    def layerStat(self):$/;"	m	class:VMem
linkComputationUnit	Components/OutputBuffer.py	/^    def linkComputationUnit(self, computation_unit: ComputationUnit) -> None:$/;"	m	class:OutputBuffer
linkInputBuffer	Components/ComputationUnit.py	/^    def linkInputBuffer(self, input_buffer: InputBuffer) -> None:$/;"	m	class:ComputationUnit
linkOutputBuffer	Components/VMem.py	/^    def linkOutputBuffer(self, output_buffer: OutputBuffer) -> None:$/;"	m	class:VMem
linkVMem	Components/InputBuffer.py	/^    def linkVMem(self, v_mem: VMem) -> None:$/;"	m	class:InputBuffer
loadInput	Components/VMem.py	/^    def loadInput(self, image: np.array) -> None:$/;"	m	class:VMem
loadModel	uArch.py	/^    def loadModel(self, model_path: str) -> None:$/;"	m	class:uArch
loadWeight	uArch.py	/^    def loadWeight(self, weight_path: str) -> None:$/;"	m	class:uArch
main	Sim.py	/^def main(args: argparse.Namespace) -> None:$/;"	f
memcpy	Utility.py	/^def memcpy(dst: np.array, src: np.array, start: int = 0, count: int = -1) -> None:$/;"	f
model	UNet/model.py	/^    model = unet()$/;"	v
model	UNet/test.py	/^model = unet()$/;"	v
model_from_json	uArch.py	/^from tensorflow.keras.models import model_from_json$/;"	i
next	Components/InputBuffer.py	/^    def next(self) -> None:$/;"	m	class:KernelPostion
np	Components/VMem.py	/^import numpy as np$/;"	i
np	Layer.py	/^import numpy as np$/;"	i
np	UNet/data.py	/^import numpy as np $/;"	i
np	Utility.py	/^import numpy as np$/;"	i
np	uArch.py	/^import numpy as np$/;"	i
os	UNet/data.py	/^import os$/;"	i
parseArgs	Sim.py	/^def parseArgs() -> argparse.Namespace:$/;"	f
postProcess	Components/OutputBuffer.py	/^    def postProcess(self) -> None:$/;"	m	class:OutputBuffer
print_function	UNet/data.py	/^from __future__ import print_function$/;"	i
quantize8	Utility.py	/^def quantize8(value: np.array, fl: int) -> np.array:$/;"	f
read	Components/VMem.py	/^    def read(self, input_buffer: InputBuffer) -> None:$/;"	m	class:VMem
requestData	Components/OutputBuffer.py	/^    def requestData(self) -> None:$/;"	m	class:OutputBuffer
requestOutput	Components/VMem.py	/^    def requestOutput(self) -> bool:$/;"	m	class:VMem
reset	Components/InputBuffer.py	/^    def reset(self, strides: int, kernel_num: int) -> None:$/;"	m	class:KernelPostion
results	UNet/test.py	/^results = model.predict_generator(testGene,30,verbose=1)$/;"	v
run	uArch.py	/^    def run(self, input_path: str) -> np.array:$/;"	m	class:uArch
saveResult	UNet/data.py	/^def saveResult(save_path,npyfile,flag_multi_class = False,num_class = 2):$/;"	f
sendData	Components/InputBuffer.py	/^    def sendData(self) -> tuple:$/;"	m	class:InputBuffer
setConcatParam	Layer.py	/^    def setConcatParam(self, src: str, dst: str) -> None:$/;"	m	class:Layer
setConvParam	Layer.py	/^    def setConvParam(self, filters: int, kernel_size: tuple, strides: int, pad: PadType) -> None:$/;"	m	class:Layer
setDropoutParam	Layer.py	/^    def setDropoutParam(self, rate: float) -> None:$/;"	m	class:Layer
setInputParam	Layer.py	/^    def setInputParam(self, input_shape: tuple) -> None:$/;"	m	class:Layer
setMaxPoolingParam	Layer.py	/^    def setMaxPoolingParam(self, kernel_size: tuple, strides: int, pad: PadType) -> None:$/;"	m	class:Layer
setUpSamplingParam	Layer.py	/^    def setUpSamplingParam(self, kernel_size: tuple) -> None:$/;"	m	class:Layer
setWeigtsBias	Components/VMem.py	/^    def setWeigtsBias(self, layer_name: str, weights: np.array, bias: np.array) -> None:$/;"	m	class:VMem
setWeigtsBias	Layer.py	/^    def setWeigtsBias(self, weights: np.array, bias: np.array) -> None:$/;"	m	class:Layer
skimage	UNet/data.py	/^import skimage.io as io$/;"	i
skimage	UNet/data.py	/^import skimage.transform as trans$/;"	i
skimage	Utility.py	/^        import skimage.io as io$/;"	i
skimage	Utility.py	/^        import skimage.transform as trans$/;"	i
skimage	uArch.py	/^import skimage.io as io$/;"	i
skimage	uArch.py	/^import skimage.transform as trans$/;"	i
testGene	UNet/test.py	/^testGene = testGenerator("testData")$/;"	v
testGenerator	UNet/data.py	/^def testGenerator(test_path,num_image = 30,target_size = (256,256),flag_multi_class = False,as_gray = True):$/;"	f
test_memcpy	Utility.py	/^    def test_memcpy():$/;"	f	function:memcpy
test_quantize8	Utility.py	/^    def test_quantize8():$/;"	f	function:memcpy
trainGenerator	UNet/data.py	/^def trainGenerator(batch_size,train_path,image_folder,mask_folder,aug_dict,image_color_mode = "grayscale",$/;"	f
trans	UNet/data.py	/^import skimage.transform as trans$/;"	i
trans	Utility.py	/^        import skimage.transform as trans$/;"	i
trans	uArch.py	/^import skimage.transform as trans$/;"	i
uArch	Sim.py	/^from uArch import uArch$/;"	i
uArch	uArch.py	/^class uArch():$/;"	c
unet	UNet/model.py	/^def unet(pretrained_weights = None,input_size = (256,256,1)):$/;"	f
vMemWrite	Components/OutputBuffer.py	/^    def vMemWrite(self, v_mem: VMem) -> bool:$/;"	m	class:OutputBuffer
write	Components/VMem.py	/^    def write(self, data: np.array) -> None:$/;"	m	class:VMem
