!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Bicyclist	UNet/data.py	/^Bicyclist = [0,128,192]$/;"	v
Building	UNet/data.py	/^Building = [128,0,0]$/;"	v
COLOR_DICT	UNet/data.py	/^COLOR_DICT = np.array([Sky, Building, Pole, Road, Pavement,$/;"	v
CONCAT	Layer.py	/^    CONCAT = 4$/;"	v	class:LayerType
CONV	Layer.py	/^    CONV = 1$/;"	v	class:LayerType
Car	UNet/data.py	/^Car = [64,0,128]$/;"	v
ComputationUnit	Components/ComputationUnit.py	/^class ComputationUnit():$/;"	c
ComputationUnit	Components/InputBuffer.py	/^from . import ComputationUnit as ComputationUnit$/;"	i
ComputationUnit	Components/OutputBuffer.py	/^from . import ComputationUnit as ComputationUnit$/;"	i
ComputationUnit	uArch.py	/^from Components.ComputationUnit import ComputationUnit$/;"	i
DOWN_SAMPLE	Layer.py	/^    DOWN_SAMPLE = 2$/;"	v	class:LayerType
DROP_OUT	Layer.py	/^    DROP_OUT = 6$/;"	v	class:LayerType
Fence	UNet/data.py	/^Fence = [64,64,128]$/;"	v
INPUT	Layer.py	/^    INPUT = 5$/;"	v	class:LayerType
ImageDataGenerator	UNet/data.py	/^from tensorflow.keras.preprocessing.image import ImageDataGenerator$/;"	i
InputBuffer	Components/ComputationUnit.py	/^from . import InputBuffer as InputBuffer$/;"	i
InputBuffer	Components/InputBuffer.py	/^class InputBuffer():$/;"	c
InputBuffer	Components/VMem.py	/^from . import InputBuffer as InputBuffer$/;"	i
InputBuffer	uArch.py	/^from Components.InputBuffer import InputBuffer$/;"	i
KernelPostion	Components/InputBuffer.py	/^class KernelPostion():$/;"	c
Layer	Components/VMem.py	/^from Layer import Layer, LayerType, PadType$/;"	i
Layer	Layer.py	/^class Layer():$/;"	c
LayerType	Components/VMem.py	/^from Layer import Layer, LayerType, PadType$/;"	i
LayerType	Layer.py	/^class LayerType(enum.Enum):$/;"	c
LearningRateScheduler	UNet/model.py	/^from tensorflow.keras.callbacks import ModelCheckpoint, LearningRateScheduler$/;"	i
LearningRateScheduler	UNet/model_light.py	/^from tensorflow.keras.callbacks import ModelCheckpoint, LearningRateScheduler$/;"	i
ModelCheckpoint	UNet/model.py	/^from tensorflow.keras.callbacks import ModelCheckpoint, LearningRateScheduler$/;"	i
ModelCheckpoint	UNet/model_light.py	/^from tensorflow.keras.callbacks import ModelCheckpoint, LearningRateScheduler$/;"	i
NONE	Layer.py	/^    NONE = 3  # for non-convolutional layers$/;"	v	class:PadType
OutputBuffer	Components/ComputationUnit.py	/^from . import OutputBuffer as OutputBuffer$/;"	i
OutputBuffer	Components/OutputBuffer.py	/^class OutputBuffer():$/;"	c
OutputBuffer	Components/VMem.py	/^from . import OutputBuffer as OutputBuffer$/;"	i
OutputBuffer	uArch.py	/^from Components.OutputBuffer import OutputBuffer$/;"	i
PE_COMPUTATIONAL_CAPABILITY	Components/ComputationUnit.py	/^PE_COMPUTATIONAL_CAPABILITY = 32$/;"	v
PadType	Components/VMem.py	/^from Layer import Layer, LayerType, PadType$/;"	i
PadType	Layer.py	/^class PadType(enum.Enum):$/;"	c
Pavement	UNet/data.py	/^Pavement = [60,40,222]$/;"	v
Pedestrian	UNet/data.py	/^Pedestrian = [64,64,0]$/;"	v
Pole	UNet/data.py	/^Pole = [192,192,128]$/;"	v
Quantizer	Components/OutputBuffer.py	/^from Utility import Quantizer$/;"	i
Quantizer	Utility.py	/^class Quantizer:$/;"	c
Quantizer	uArch.py	/^from Utility import Quantizer$/;"	i
Road	UNet/data.py	/^Road = [128,64,128]$/;"	v
SAME	Layer.py	/^    SAME = 1$/;"	v	class:PadType
SignSymbol	UNet/data.py	/^SignSymbol = [192,128,128]$/;"	v
Sky	UNet/data.py	/^Sky = [128,128,128]$/;"	v
Tree	UNet/data.py	/^Tree = [128,128,0]$/;"	v
UP_SAMPLE	Layer.py	/^    UP_SAMPLE = 3$/;"	v	class:LayerType
Union	Components/VMem.py	/^from typing import Union$/;"	i
Unlabelled	UNet/data.py	/^Unlabelled = [0,0,0]$/;"	v
VALID	Layer.py	/^    VALID = 2$/;"	v	class:PadType
VMem	Components/InputBuffer.py	/^from . import VMem as VMem$/;"	i
VMem	Components/OutputBuffer.py	/^from . import VMem as VMem$/;"	i
VMem	Components/VMem.py	/^class VMem():$/;"	c
VMem	uArch.py	/^from Components.VMem import VMem$/;"	i
_7_layer_model	UNet/model.py	/^    _7_layer_model = Model(inputs = model.input, outputs = layer7.output)$/;"	v
_7_out	UNet/model.py	/^    _7_out = _7_layer_model.predict(img.reshape((1, 256, 256, 1)))[0]$/;"	v
_8_layer_model	UNet/model.py	/^    _8_layer_model = Model(inputs = model.input, outputs = layer8.output)$/;"	v
_8_out	UNet/model.py	/^    _8_out = _8_layer_model.predict(img.reshape((1, 256, 256, 1)))[0]$/;"	v
_9_layer_model	UNet/model.py	/^    _9_layer_model = Model(inputs = model.input, outputs = layer9.output)$/;"	v
_9_out	UNet/model.py	/^    _9_out = _9_layer_model.predict(img.reshape((1, 256, 256, 1)))[0]$/;"	v
__init__	Components/ComputationUnit.py	/^    def __init__(self, pe_array_size: int) -> None:$/;"	m	class:ComputationUnit
__init__	Components/InputBuffer.py	/^    def __init__(self):$/;"	m	class:InputBuffer
__init__	Components/InputBuffer.py	/^    def __init__(self, strides: int, kernel_num: int, kernel_size: tuple, output_shape: tuple):$/;"	m	class:KernelPostion
__init__	Components/OutputBuffer.py	/^    def __init__(self) -> None:$/;"	m	class:OutputBuffer
__init__	Components/VMem.py	/^    def __init__(self, verbose: int = 0) -> None:$/;"	m	class:VMem
__init__	Layer.py	/^    def __init__(self, layer_type: LayerType, name: str) -> None:$/;"	m	class:Layer
__init__	Utility.py	/^    def __init__(self):$/;"	m	class:Quantizer
__init__	uArch.py	/^    def __init__(self, pe_array_size: int = 32, verbose: int = 0) -> None:$/;"	m	class:uArch
__instance	Utility.py	/^    __instance = None$/;"	v	class:Quantizer
__str__	Components/InputBuffer.py	/^    def __str__(self):$/;"	m	class:KernelPostion	file:
__str__	Layer.py	/^    def __str__(self) -> str:$/;"	m	class:Layer	file:
_check	Components/InputBuffer.py	/^    def _check(self) -> None:$/;"	m	class:InputBuffer
_computeConcatShape	Layer.py	/^    def _computeConcatShape(self, layer_map: dict) -> tuple:$/;"	m	class:Layer
_computeConvShape	Layer.py	/^    def _computeConvShape(self, input_shape: tuple) -> tuple:$/;"	m	class:Layer
_computeDownSampleShape	Layer.py	/^    def _computeDownSampleShape(self, input_shape: tuple) -> tuple:$/;"	m	class:Layer
_computeShape	uArch.py	/^    def _computeShape(self) -> None:$/;"	m	class:uArch
_computeUpSampleShape	Layer.py	/^    def _computeUpSampleShape(self, input_shape: tuple) -> tuple:$/;"	m	class:Layer
_loadVMem	uArch.py	/^    def _loadVMem(self) -> None:$/;"	m	class:uArch
_nextRound	Components/InputBuffer.py	/^    def _nextRound(self, max_multiplications: int) -> tuple:$/;"	m	class:InputBuffer
_paramTypeTransfrom	Components/VMem.py	/^    def _paramTypeTransfrom(self, kernel_size: Union[int,tuple], strides: Union[int,tuple], pad: Union[str,PadType]) -> tuple:$/;"	m	class:VMem
_read	Components/InputBuffer.py	/^    def _read(self) -> None:$/;"	m	class:InputBuffer
_readInput	uArch.py	/^    def _readInput(self, input_path: str) -> np.array:$/;"	m	class:uArch
addConcatLayer	Components/VMem.py	/^    def addConcatLayer(self, name: str, src: str, dst: str) -> None:$/;"	m	class:VMem
addConvLayer	Components/VMem.py	/^    def addConvLayer(self, name: str, filters: int, activation: str, kernel_size: Union[int,tuple], strides: Union[int,tuple], pad: Union[str,PadType]) -> None:$/;"	m	class:VMem
addDropoutLayer	Components/VMem.py	/^    def addDropoutLayer(self, name: str, rate: float) -> None:$/;"	m	class:VMem
addInputLayer	Components/VMem.py	/^    def addInputLayer(self, name: str, input_shape: tuple) -> None:$/;"	m	class:VMem
addMaxPoolingLayer	Components/VMem.py	/^    def addMaxPoolingLayer(self, name: str, kernel_size: Union[int,tuple], strides: Union[int,tuple], pad: Union[str,PadType]) -> None:$/;"	m	class:VMem
addUpSamplingLayer	Components/VMem.py	/^    def addUpSamplingLayer(self, name: str, kernel_size: Union[int,tuple]) -> None:$/;"	m	class:VMem
adjustData	UNet/data.py	/^def adjustData(img,mask,flag_multi_class,num_class):$/;"	f
argparse	Sim.py	/^import argparse, time$/;"	i
block_reduce	Components/OutputBuffer.py	/^from skimage.measure import block_reduce$/;"	i
check	UNet/model_light.py	/^    check = test.predict(inn)[0]$/;"	v
checkData	Components/OutputBuffer.py	/^    def checkData(self) -> None:$/;"	m	class:OutputBuffer
computeNextRound	Components/ComputationUnit.py	/^    def computeNextRound(self) -> None:$/;"	m	class:ComputationUnit
computeShape	Layer.py	/^    def computeShape(self, layer_map: dict, input_shape: tuple) -> tuple:$/;"	m	class:Layer
concat_count	UNet/model_light.py	/^    concat_count = 1$/;"	v
conv_count	UNet/model_light.py	/^    conv_count = 1$/;"	v
dataFetch	Components/ComputationUnit.py	/^    def dataFetch(self) -> tuple:$/;"	m	class:ComputationUnit
dataWrite	Components/ComputationUnit.py	/^    def dataWrite(self, output_buffer: OutputBuffer) -> tuple:$/;"	m	class:ComputationUnit
enum	Layer.py	/^import enum$/;"	i
geneTrainNpy	UNet/data.py	/^def geneTrainNpy(image_path,mask_path,flag_multi_class = False,num_class = 2,image_prefix = "image",mask_prefix = "mask",image_as_gray = True,mask_as_gray = True):$/;"	f
getInputShape	Layer.py	/^    def getInputShape(self) -> tuple:$/;"	m	class:Layer
getInstance	Utility.py	/^    def getInstance():$/;"	m	class:Quantizer
getModelInputShape	Components/VMem.py	/^    def getModelInputShape(self) -> tuple:$/;"	m	class:VMem
glob	UNet/data.py	/^import glob$/;"	i
hasNext	Components/InputBuffer.py	/^    def hasNext(self):$/;"	m	class:KernelPostion
img	UNet/model.py	/^    img = img \/ 255$/;"	v
img	UNet/model.py	/^    img = io.imread('.\/testData\/0.png', as_gray=True)$/;"	v
img	UNet/model.py	/^    img = trans.resize(image=img, output_shape=(256, 256, 1))$/;"	v
img	UNet/model_light.py	/^    img = img \/ 255$/;"	v
img	UNet/model_light.py	/^    img = io.imread('.\/testData\/0.png', as_gray=True)$/;"	v
img	UNet/model_light.py	/^    img = trans.resize(image=img, output_shape=(256, 256, 1)).reshape((1, 256, 256, 1))$/;"	v
inn	UNet/model_light.py	/^    inn = np.zeros((1,64,64,128))$/;"	v
io	UNet/data.py	/^import skimage.io as io$/;"	i
io	UNet/model.py	/^    import skimage.io as io$/;"	i
io	UNet/model_light.py	/^    import skimage.io as io$/;"	i
io	Utility.py	/^        import skimage.io as io$/;"	i
io	uArch.py	/^import skimage.io as io$/;"	i
isRoundFinished	Components/InputBuffer.py	/^    def isRoundFinished(self) -> bool:$/;"	m	class:InputBuffer
labelVisualize	UNet/data.py	/^def labelVisualize(num_class,color_dict,img):$/;"	f
layer	UNet/model_light.py	/^    layer = model.get_layer('conv2d_8')$/;"	v
layer1	UNet/model.py	/^    layer1 = model.get_layer('conv2d')$/;"	v
layer10	UNet/model.py	/^    layer10 = model.get_layer('conv2d_6')$/;"	v
layer2	UNet/model.py	/^    layer2 = model.get_layer('conv2d_1')$/;"	v
layer3	UNet/model.py	/^    layer3 = model.get_layer('max_pooling2d')$/;"	v
layer4	UNet/model.py	/^    layer4 = model.get_layer('conv2d_2')$/;"	v
layer5	UNet/model.py	/^    layer5 = model.get_layer('conv2d_3')$/;"	v
layer6	UNet/model.py	/^    layer6 = model.get_layer('max_pooling2d_1')$/;"	v
layer7	UNet/model.py	/^    layer7 = model.get_layer('conv2d_4')$/;"	v
layer8	UNet/model.py	/^    layer8 = model.get_layer('conv2d_5')$/;"	v
layer9	UNet/model.py	/^    layer9 = model.get_layer('max_pooling2d_2')$/;"	v
layerStat	Components/VMem.py	/^    def layerStat(self):$/;"	m	class:VMem
linkComputationUnit	Components/OutputBuffer.py	/^    def linkComputationUnit(self, computation_unit: ComputationUnit) -> None:$/;"	m	class:OutputBuffer
linkInputBuffer	Components/ComputationUnit.py	/^    def linkInputBuffer(self, input_buffer: InputBuffer) -> None:$/;"	m	class:ComputationUnit
linkOutputBuffer	Components/VMem.py	/^    def linkOutputBuffer(self, output_buffer: OutputBuffer) -> None:$/;"	m	class:VMem
linkVMem	Components/InputBuffer.py	/^    def linkVMem(self, v_mem: VMem) -> None:$/;"	m	class:InputBuffer
loadInput	Components/VMem.py	/^    def loadInput(self, image: np.array) -> None:$/;"	m	class:VMem
loadModel	uArch.py	/^    def loadModel(self, model_path: str) -> None:$/;"	m	class:uArch
loadWeight	uArch.py	/^    def loadWeight(self, weight_path: str) -> None:$/;"	m	class:uArch
main	Sim.py	/^def main(args: argparse.Namespace) -> None:$/;"	f
memcpy	Utility.py	/^def memcpy(dst: np.array, src: np.array, start: int = 0, count: int = -1) -> None:$/;"	f
model	UNet/model.py	/^    model = unet()$/;"	v
model	UNet/model_light.py	/^    model = unet()$/;"	v
model	UNet/test.py	/^model = unet()$/;"	v
model	UNet/test_light.py	/^model = unet()$/;"	v
model_from_json	uArch.py	/^from tensorflow.keras.models import model_from_json$/;"	i
next	Components/InputBuffer.py	/^    def next(self, max_kernel_usage: int) -> tuple:$/;"	m	class:KernelPostion
np	Components/ComputationUnit.py	/^import numpy as np$/;"	i
np	Components/InputBuffer.py	/^import numpy as np$/;"	i
np	Components/OutputBuffer.py	/^import numpy as np$/;"	i
np	Components/VMem.py	/^import numpy as np$/;"	i
np	Layer.py	/^import numpy as np$/;"	i
np	UNet/data.py	/^import numpy as np $/;"	i
np	UNet/model.py	/^    import numpy as np$/;"	i
np	UNet/model_light.py	/^    import numpy as np$/;"	i
np	Utility.py	/^import numpy as np$/;"	i
np	uArch.py	/^import numpy as np$/;"	i
os	UNet/data.py	/^import os$/;"	i
parseArgs	Sim.py	/^def parseArgs() -> argparse.Namespace:$/;"	f
pathlib	UNet/data.py	/^import pathlib$/;"	i
pool_count	UNet/model_light.py	/^    pool_count = 1$/;"	v
postProcess	Components/OutputBuffer.py	/^    def postProcess(self) -> None:$/;"	m	class:OutputBuffer
print_function	UNet/data.py	/^from __future__ import print_function$/;"	i
quantize	Utility.py	/^    def quantize(self, array: np.array) -> np.array:$/;"	m	class:Quantizer
requestData	Components/OutputBuffer.py	/^    def requestData(self) -> None:$/;"	m	class:OutputBuffer
requestOutput	Components/VMem.py	/^    def requestOutput(self) -> bool:$/;"	m	class:VMem
resetBuffer	Components/OutputBuffer.py	/^    def resetBuffer(self, shape: tuple) -> None:$/;"	m	class:OutputBuffer
resetKernelPosition	Components/InputBuffer.py	/^    def resetKernelPosition(self, strides: int, kernel_num: int, kernel_size: tuple, output_shape: tuple) -> None:$/;"	m	class:InputBuffer
resetStatusLine	Components/InputBuffer.py	/^    def resetStatusLine(self):$/;"	m	class:KernelPostion
results	UNet/test.py	/^results = model.predict_generator(testGene,30,verbose=1)$/;"	v
results	UNet/test_light.py	/^results = model.predict_generator(testGene,30,verbose=1)$/;"	v
ret	UNet/model_light.py	/^            ret = test.predict(img)[0]$/;"	v
run	uArch.py	/^    def run(self, input_path: str) -> np.array:$/;"	m	class:uArch
saveResult	Sim.py	/^from UNet.data import saveResult$/;"	i
saveResult	UNet/data.py	/^def saveResult(npyfile,save_path,save_name=None,flag_multi_class = False,num_class = 2):$/;"	f
send	Components/VMem.py	/^    def send(self, input_buffer: InputBuffer) -> None:$/;"	m	class:VMem
sendData	Components/InputBuffer.py	/^    def sendData(self, max_multiplications: int) -> tuple:$/;"	m	class:InputBuffer
setBiasActivation	Components/OutputBuffer.py	/^    def setBiasActivation(self, bias: np.array, activation: str) -> None:$/;"	m	class:OutputBuffer
setComputationMode	uArch.py	/^    def setComputationMode(self, word_length: int) -> None:$/;"	m	class:uArch
setConcatParam	Layer.py	/^    def setConcatParam(self, src: str, dst: str) -> None:$/;"	m	class:Layer
setConcate	Components/OutputBuffer.py	/^    def setConcate(self) -> None:$/;"	m	class:OutputBuffer
setConvParam	Layer.py	/^    def setConvParam(self, filters: int, activation: str, kernel_size: tuple, strides: int, pad: PadType) -> None:$/;"	m	class:Layer
setDropoutParam	Layer.py	/^    def setDropoutParam(self, rate: float) -> None:$/;"	m	class:Layer
setDropoutRatio	Components/OutputBuffer.py	/^    def setDropoutRatio(self, ratio: float) -> None:$/;"	m	class:OutputBuffer
setFinalRound	Components/OutputBuffer.py	/^    def setFinalRound(self) -> None:$/;"	m	class:OutputBuffer
setInputParam	Layer.py	/^    def setInputParam(self, input_shape: tuple) -> None:$/;"	m	class:Layer
setMaxPoolingParam	Layer.py	/^    def setMaxPoolingParam(self, kernel_size: tuple, strides: int, pad: PadType) -> None:$/;"	m	class:Layer
setPooling	Components/OutputBuffer.py	/^    def setPooling(self, pool_size: tuple) -> None:$/;"	m	class:OutputBuffer
setQuantize	Components/OutputBuffer.py	/^    def setQuantize(self) -> None:$/;"	m	class:OutputBuffer
setSaveResidual	Components/OutputBuffer.py	/^    def setSaveResidual(self) -> None:$/;"	m	class:OutputBuffer
setUpSamplingParam	Layer.py	/^    def setUpSamplingParam(self, kernel_size: tuple) -> None:$/;"	m	class:Layer
setUpsample	Components/OutputBuffer.py	/^    def setUpsample(self, kernel_size: tuple) -> None:$/;"	m	class:OutputBuffer
setWeigtsBias	Components/VMem.py	/^    def setWeigtsBias(self, layer_name: str, weights: np.array, bias: np.array) -> None:$/;"	m	class:VMem
setWeigtsBias	Layer.py	/^    def setWeigtsBias(self, weights: np.array, bias: np.array) -> None:$/;"	m	class:Layer
setWordLength	Utility.py	/^    def setWordLength(self, word_length: int) -> None:$/;"	m	class:Quantizer
showUsage	uArch.py	/^    def showUsage(self) -> None:$/;"	m	class:uArch
skimage	UNet/data.py	/^import skimage.io as io$/;"	i
skimage	UNet/data.py	/^import skimage.transform as trans$/;"	i
skimage	UNet/model.py	/^    import skimage.io as io$/;"	i
skimage	UNet/model.py	/^    import skimage.transform as trans$/;"	i
skimage	UNet/model_light.py	/^    import skimage.io as io$/;"	i
skimage	UNet/model_light.py	/^    import skimage.transform as trans$/;"	i
skimage	Utility.py	/^        import skimage.io as io$/;"	i
skimage	Utility.py	/^        import skimage.transform as trans$/;"	i
skimage	uArch.py	/^import skimage.io as io$/;"	i
skimage	uArch.py	/^import skimage.transform as trans$/;"	i
sys	Components/OutputBuffer.py	/^import sys$/;"	i
test	UNet/model_light.py	/^            test = Model(inputs=model.input, outputs=layer.output)$/;"	v
test	UNet/model_light.py	/^    test = Model(inputs=layer.input, outputs=layer.output)$/;"	v
testGene	UNet/test.py	/^testGene = testGenerator("testData")$/;"	v
testGene	UNet/test_light.py	/^testGene = testGenerator("testData")$/;"	v
testGenerator	UNet/data.py	/^def testGenerator(test_path,num_image = 30,target_size = (256,256),flag_multi_class = False,as_gray = True):$/;"	f
test_memcpy	Utility.py	/^    def test_memcpy():$/;"	f	function:memcpy
test_quantizer	Utility.py	/^    def test_quantizer():$/;"	f	function:memcpy
time	Sim.py	/^import argparse, time$/;"	i
trainGenerator	UNet/data.py	/^def trainGenerator(batch_size,train_path,image_folder,mask_folder,aug_dict,image_color_mode = "grayscale",$/;"	f
trans	UNet/data.py	/^import skimage.transform as trans$/;"	i
trans	UNet/model.py	/^    import skimage.transform as trans$/;"	i
trans	UNet/model_light.py	/^    import skimage.transform as trans$/;"	i
trans	Utility.py	/^        import skimage.transform as trans$/;"	i
trans	uArch.py	/^import skimage.transform as trans$/;"	i
uArch	Sim.py	/^from uArch import uArch$/;"	i
uArch	uArch.py	/^class uArch():$/;"	c
unet	UNet/model.py	/^def unet(pretrained_weights = None,input_size = (256,256,1)):$/;"	f
unet	UNet/model_light.py	/^def unet(pretrained_weights = None,input_size = (256,256,1)):$/;"	f
up_sample_count	UNet/model_light.py	/^    up_sample_count = 1$/;"	v
usage	Components/ComputationUnit.py	/^    def usage(self) -> None:$/;"	m	class:ComputationUnit
vMemWrite	Components/OutputBuffer.py	/^    def vMemWrite(self, v_mem: VMem) -> bool:$/;"	m	class:OutputBuffer
write	Components/VMem.py	/^    def write(self, data: np.array) -> None:$/;"	m	class:VMem
writeData	Components/OutputBuffer.py	/^    def writeData(self, data: float, position: tuple, channels: range) -> None:$/;"	m	class:OutputBuffer
